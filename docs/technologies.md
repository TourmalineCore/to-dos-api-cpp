# Applied technologies

## C++

## Package manager

### Overview

**Definition:** A tool that automates the process of obtaining, installing, updating, and managing project dependencies.

**Purpose:** Solves the "dependency hell" problem—complexities in managing library versions, compatibility, and builds in C++ projects.

### Selection Criteria

#### Key factors for decision-making:

**Ease of use**
- Simplicity of setup and initial configuration
- Intuitive commands and workflows
- Quality of documentation and examples

**Package ecosystem**
- Number of available libraries in the repository
- Currency of popular library versions
- Support for creating custom packages

**Build system integration**
- Support for CMake, Make, MSBuild
- Non-intrusive integration (does not require changes to existing build scripts)
- Generation of configuration files

**Performance**
- Time for dependency download and installation
- Support for binary packages vs source builds
- Efficiency of caching

### Comparative Table of Popular Solutions

| Criterion           | Manager 1 | Manager 2 |
|---------------------|-----------|-----------|
| First               |     -     |     -     |
| Second              |     +     |     -     |

### Rationale for Selection

#### Manager 1 – Chosen solution

**Advantages:**
- First
- Second

**Disadvantages:**
- First
- Second

#### Why not Manager 2?

### Practical Considerations

For this project, Manager 1 is optimal because:

1. First
2. Second

**Alternative choice:** if there are special requirements for the project.

## Compiler

## Build system

## Web Framework

## ORM

## E2E Tests